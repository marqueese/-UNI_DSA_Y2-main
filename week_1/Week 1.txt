#1. Implement a Queue u

class Queue:

    def __init__(self):
        self.data = []
        self.head = 0
        self.tail = -1
        self.max_size = 15


    def enqueue(self, newData):
        #self.data.append(newData)
        print("Enqueue the data " + str(newData))
        if self.tail == self.max_size - 1:
        #When the queue is full
            raise OverflowError("Cannot insert into a full queue.")
        self.tail += 1
        self.data.insert(self.tail, newData)
        print("Now the tail index is " + str(self.tail))


    def dequeue(self):
        #return self.data.pop(0)
        if self.tail == -1:
            #When the queue is empty
            raise IndexError("Cannot delete from an empty queue.")
        removed = self.data[self.head]
        print("Dequeue the data " + str(removed))
        temp = self.head
        while temp < self.tail:
            temp += 1
            self.data[temp - 1] = self.data[temp]
        del self.data[temp]
        self.tail -= 1
        return removed


    def peek(self):
        #return self.data(0)
        if self.tail == -1:
        #When the queue is empty
            print("Cannot peek from an empty queue.")
        print("Peek the head")
        return self.data[self.head]

    def length(self):
        #return len(self.data)
        return self.tail + 1
    
    def print_message(self):
        print("The queue size is " + str(self.length()) + " The first element is " + str(self.peek()))
    
    def print_all(self):
        if self.tail != -1: #if the tail, is not set to -1 meaning the queue is not empty
            print(self.dequeue())

    
def main():
    q = Queue()
    for j in range(10,20):
        q.enqueue(50 - j)
    q.print_message()
    for i in range(10,16):
        q.dequeue()
    q.print_message()
    q.print_all()


main()